package persistence

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"chat-app/internal/domain/chat" // Importing domain chat package
	"chat-app/internal/domain/user" // For user.User struct in Room.Users (if populated)

	_ "github.com/lib/pq"
)

// PostgresRoomRepository implements the chat.RoomRepository interface using PostgreSQL.
type PostgresRoomRepository struct {
	db *sql.DB
}

// NewPostgresRoomRepository creates a new instance of PostgresRoomRepository.
func NewPostgresRoomRepository(db *sql.DB) *PostgresRoomRepository {
	return &PostgresRoomRepository{db: db}
}

// Create inserts a new room into the database.
// Assumes Room.ID is generated by the service layer (e.g. UUID)
func (r *PostgresRoomRepository) Create(ctx context.Context, room *chat.Room) error {
	query := `INSERT INTO rooms (id, name, description, created_by, is_private, created_at, updated_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7)`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare create room statement: %w", err)
	}
	defer stmt.Close()

	room.CreatedAt = time.Now().UTC()
	room.UpdatedAt = time.Now().UTC()

	_, err = stmt.ExecContext(ctx, room.ID, room.Name, room.Description, room.CreatedBy, room.IsPrivate, room.CreatedAt, room.UpdatedAt)
	if err != nil {
		// Check for pq specific error, e.g. unique constraint on name if applicable
		// pqErr, ok := err.(*pq.Error)
		// if ok && pqErr.Code.Name() == "unique_violation" { ... }
		return fmt.Errorf("failed to create room: %w", err)
	}
	return nil
}

// FindByID retrieves a room by its ID.
// For now, it does not populate Room.Users or Room.Messages.
// These could be populated by separate calls or more complex queries if needed.
func (r *PostgresRoomRepository) FindByID(ctx context.Context, id string) (*chat.Room, error) {
	query := `SELECT id, name, description, created_by, is_private, created_at, updated_at
              FROM rooms WHERE id = $1`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare find room by id statement: %w", err)
	}
	defer stmt.Close()

	room := &chat.Room{}
	err = stmt.QueryRowContext(ctx, id).Scan(
		&room.ID, &room.Name, &room.Description, &room.CreatedBy,
		&room.IsPrivate, &room.CreatedAt, &room.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, chat.ErrRoomNotFound // Domain-specific error
		}
		return nil, fmt.Errorf("failed to find room by id: %w", err)
	}
	// room.Users and room.Messages are not populated here.
	return room, nil
}

// FindByName retrieves a room by its name. (Useful for checking name uniqueness)
func (r *PostgresRoomRepository) FindByName(ctx context.Context, name string) (*chat.Room, error) {
	query := `SELECT id, name, description, created_by, is_private, created_at, updated_at
              FROM rooms WHERE name = $1`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare find room by name statement: %w", err)
	}
	defer stmt.Close()

	room := &chat.Room{}
	err = stmt.QueryRowContext(ctx, name).Scan(
		&room.ID, &room.Name, &room.Description, &room.CreatedBy,
		&room.IsPrivate, &room.CreatedAt, &room.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, chat.ErrRoomNotFound
		}
		return nil, fmt.Errorf("failed to find room by name: %w", err)
	}
	return room, nil
}


// AddUserToRoom adds a user to a room in the room_users join table.
func (r *PostgresRoomRepository) AddUserToRoom(ctx context.Context, roomID string, userID string) error {
	// First, check if user is already in the room to provide a specific error or avoid duplication
	// This check can also be done with INSERT ... ON CONFLICT DO NOTHING if we don't need specific error
	var exists bool
	checkQuery := `SELECT EXISTS(SELECT 1 FROM room_users WHERE room_id = $1 AND user_id = $2)`
	err := r.db.QueryRowContext(ctx, checkQuery, roomID, userID).Scan(&exists)
	if err != nil {
		return fmt.Errorf("failed to check if user in room: %w", err)
	}
	if exists {
		return chat.ErrUserAlreadyInRoom // Or just return nil if idempotency is desired
	}

	query := `INSERT INTO room_users (room_id, user_id, joined_at) VALUES ($1, $2, $3)`
	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare add user to room statement: %w", err)
	}
	defer stmt.Close()

	_, err = stmt.ExecContext(ctx, roomID, userID, time.Now().UTC())
	if err != nil {
		// Handle potential foreign key violations (e.g., roomID or userID doesn't exist)
		return fmt.Errorf("failed to add user to room: %w", err)
	}
	return nil
}

// RemoveUserFromRoom removes a user from a room in the room_users join table.
func (r *PostgresRoomRepository) RemoveUserFromRoom(ctx context.Context, roomID string, userID string) error {
	query := `DELETE FROM room_users WHERE room_id = $1 AND user_id = $2`
	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare remove user from room statement: %w", err)
	}
	defer stmt.Close()

	result, err := stmt.ExecContext(ctx, roomID, userID)
	if err != nil {
		return fmt.Errorf("failed to remove user from room: %w", err)
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rowsAffected == 0 {
		return chat.ErrUserNotInRoom // User was not in the room or room/user ID invalid
	}
	return nil
}

// Update modifies an existing room's details.
func (r *PostgresRoomRepository) Update(ctx context.Context, room *chat.Room) error {
	query := `UPDATE rooms SET name = $1, description = $2, is_private = $3, updated_at = $4
              WHERE id = $5`
	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare update room statement: %w", err)
	}
	defer stmt.Close()

	room.UpdatedAt = time.Now().UTC()
	result, err := stmt.ExecContext(ctx, room.Name, room.Description, room.IsPrivate, room.UpdatedAt, room.ID)
	if err != nil {
		return fmt.Errorf("failed to update room: %w", err)
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rowsAffected == 0 {
		return chat.ErrRoomNotFound
	}
	return nil
}

// Delete removes a room from the database.
// This should also handle related data, e.g., memberships in room_users, messages.
// For simplicity, this example only deletes from 'rooms'. Cascade delete or multi-step TX might be needed.
func (r *PostgresRoomRepository) Delete(ctx context.Context, id string) error {
	// In a real application, this would likely be a transaction:
	// 1. Delete from room_users where room_id = $1
	// 2. Delete from messages where room_id = $1
	// 3. Delete from rooms where id = $1
	// Or use CASCADE DELETE in PostgreSQL schema.

	query := `DELETE FROM rooms WHERE id = $1`
	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare delete room statement: %w", err)
	}
	defer stmt.Close()

	result, err := stmt.ExecContext(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to delete room: %w", err)
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rowsAffected == 0 {
		return chat.ErrRoomNotFound
	}
	return nil
}

// ListPublicRooms retrieves a paginated list of public rooms.
// Does not populate Room.Users or Room.Messages.
func (r *PostgresRoomRepository) ListPublicRooms(ctx context.Context, limit, offset int) ([]*chat.Room, error) {
	query := `SELECT id, name, description, created_by, is_private, created_at, updated_at
              FROM rooms
              WHERE is_private = FALSE
              ORDER BY created_at DESC
              LIMIT $1 OFFSET $2`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare list public rooms statement: %w", err)
	}
	defer stmt.Close()

	rows, err := stmt.QueryContext(ctx, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to list public rooms: %w", err)
	}
	defer rows.Close()

	var rooms []*chat.Room
	for rows.Next() {
		room := &chat.Room{}
		err := rows.Scan(
			&room.ID, &room.Name, &room.Description, &room.CreatedBy,
			&room.IsPrivate, &room.CreatedAt, &room.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan public room: %w", err)
		}
		rooms = append(rooms, room)
	}
	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("public room iteration error: %w", err)
	}
	return rooms, nil
}

// ListRoomsForUser retrieves a paginated list of rooms a user is part of.
// Does not populate Room.Users or Room.Messages for each room.
func (r *PostgresRoomRepository) ListRoomsForUser(ctx context.Context, userID string, limit, offset int) ([]*chat.Room, error) {
	query := `SELECT r.id, r.name, r.description, r.created_by, r.is_private, r.created_at, r.updated_at
              FROM rooms r
              JOIN room_users ru ON r.id = ru.room_id
              WHERE ru.user_id = $1
              ORDER BY r.name ASC
              LIMIT $2 OFFSET $3`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare list rooms for user statement: %w", err)
	}
	defer stmt.Close()

	rows, err := stmt.QueryContext(ctx, userID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to list rooms for user: %w", err)
	}
	defer rows.Close()

	var rooms []*chat.Room
	for rows.Next() {
		room := &chat.Room{}
		err := rows.Scan(
			&room.ID, &room.Name, &room.Description, &room.CreatedBy,
			&room.IsPrivate, &room.CreatedAt, &room.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan room for user: %w", err)
		}
		rooms = append(rooms, room)
	}
	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("user room iteration error: %w", err)
	}
	return rooms, nil
}

// Helper to get users in a room - this is an example, might not be directly on repo interface
// but used internally or by service.
func (r *PostgresRoomRepository) GetRoomUserIDs(ctx context.Context, roomID string) ([]string, error) {
    query := `SELECT user_id FROM room_users WHERE room_id = $1`
    rows, err := r.db.QueryContext(ctx, query, roomID)
    if err != nil {
        return nil, fmt.Errorf("failed to query room user IDs: %w", err)
    }
    defer rows.Close()

    var userIDs []string
    for rows.Next() {
        var userID string
        if err := rows.Scan(&userID); err != nil {
            return nil, fmt.Errorf("failed to scan user ID: %w", err)
        }
        userIDs = append(userIDs, userID)
    }
    if err = rows.Err(); err != nil {
        return nil, fmt.Errorf("room user IDs iteration error: %w", err)
    }
    return userIDs, nil
}

// GetRoomUsers fetches full user objects for a room. This is more expensive.
// Consider if this is needed at repo layer or should be handled by service layer.
func (r *PostgresRoomRepository) GetRoomUsers(ctx context.Context, roomID string) ([]*user.User, error) {
	query := `SELECT u.id, u.username, u.avatar_url, u.status
						FROM users u
						JOIN room_users ru ON u.id = ru.user_id
						WHERE ru.room_id = $1`
	rows, err := r.db.QueryContext(ctx, query, roomID)
	if err != nil {
		return nil, fmt.Errorf("failed to query room users: %w", err)
	}
	defer rows.Close()

	var users []*user.User
	for rows.Next() {
		usr := &user.User{}
		// Note: Scanning only subset of user fields needed for display in a room context.
		// PasswordHash, Description, etc., are omitted.
		if err := rows.Scan(&usr.ID, &usr.Username, &usr.AvatarURL, &usr.Status); err != nil {
			return nil, fmt.Errorf("failed to scan room user: %w", err)
		}
		users = append(users, usr)
	}
	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("room users iteration error: %w", err)
	}
	return users, nil
}
