package persistence

import (
	"context"
	"database/sql"
	"encoding/json" // For handling metadata (map[string]interface{})
	"errors"
	"fmt"
	"time"

	"chat-app/internal/domain/chat" // Importing domain chat package

	_ "github.com/lib/pq"
)

// PostgresMessageRepository implements the chat.MessageRepository interface using PostgreSQL.
type PostgresMessageRepository struct {
	db *sql.DB
}

// NewPostgresMessageRepository creates a new instance of PostgresMessageRepository.
func NewPostgresMessageRepository(db *sql.DB) *PostgresMessageRepository {
	return &PostgresMessageRepository{db: db}
}

// Create inserts a new message into the database.
// Assumes Message.ID is generated by the service layer (e.g. UUID).
// The Message.User field is not stored directly; only UserID.
func (r *PostgresMessageRepository) Create(ctx context.Context, msg *chat.Message) error {
	query := `INSERT INTO messages (id, room_id, user_id, content, type, timestamp, status, metadata, created_at, updated_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare create message statement: %w", err)
	}
	defer stmt.Close()

	msg.CreatedAt = time.Now().UTC()
	msg.UpdatedAt = time.Now().UTC()
	if msg.Timestamp.IsZero() { // Ensure timestamp is set
		msg.Timestamp = msg.CreatedAt
	}

	var metadataJSON []byte
	if msg.Metadata != nil {
		metadataJSON, err = json.Marshal(msg.Metadata)
		if err != nil {
			return fmt.Errorf("failed to marshal message metadata: %w", err)
		}
	} else {
		metadataJSON = []byte("{}") // Store as empty JSON object if nil
	}


	_, err = stmt.ExecContext(ctx, msg.ID, msg.RoomID, msg.UserID, msg.Content, msg.Type,
		msg.Timestamp, msg.Status, metadataJSON, msg.CreatedAt, msg.UpdatedAt)
	if err != nil {
		return fmt.Errorf("failed to create message: %w", err)
	}
	return nil
}

// FindByID retrieves a message by its ID.
// The Message.User field is not populated here.
func (r *PostgresMessageRepository) FindByID(ctx context.Context, id string) (*chat.Message, error) {
	query := `SELECT id, room_id, user_id, content, type, timestamp, status, metadata, created_at, updated_at
              FROM messages WHERE id = $1`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare find message by id statement: %w", err)
	}
	defer stmt.Close()

	msg := &chat.Message{}
	var metadataJSON []byte
	err = stmt.QueryRowContext(ctx, id).Scan(
		&msg.ID, &msg.RoomID, &msg.UserID, &msg.Content, &msg.Type,
		&msg.Timestamp, &msg.Status, &metadataJSON, &msg.CreatedAt, &msg.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, chat.ErrMessageNotFound // Domain-specific error
		}
		return nil, fmt.Errorf("failed to find message by id: %w", err)
	}

	if len(metadataJSON) > 0 {
		err = json.Unmarshal(metadataJSON, &msg.Metadata)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal message metadata: %w", err)
		}
	}
	return msg, nil
}

// FindByRoomID retrieves messages for a specific room with pagination, ordered by timestamp.
// The Message.User field is not populated here.
func (r *PostgresMessageRepository) FindByRoomID(ctx context.Context, roomID string, limit, offset int) ([]*chat.Message, error) {
	query := `SELECT id, room_id, user_id, content, type, timestamp, status, metadata, created_at, updated_at
              FROM messages
              WHERE room_id = $1
              ORDER BY timestamp DESC
              LIMIT $2 OFFSET $3`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare find messages by room_id statement: %w", err)
	}
	defer stmt.Close()

	rows, err := stmt.QueryContext(ctx, roomID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to find messages by room_id: %w", err)
	}
	defer rows.Close()

	var messages []*chat.Message
	for rows.Next() {
		msg := &chat.Message{}
		var metadataJSON []byte
		err := rows.Scan(
			&msg.ID, &msg.RoomID, &msg.UserID, &msg.Content, &msg.Type,
			&msg.Timestamp, &msg.Status, &metadataJSON, &msg.CreatedAt, &msg.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan message: %w", err)
		}
		if len(metadataJSON) > 0 {
			err = json.Unmarshal(metadataJSON, &msg.Metadata)
			if err != nil {
				// Log this error, but don't fail the whole query for one bad metadata
				fmt.Printf("Warning: failed to unmarshal metadata for message %s: %v\n", msg.ID, err)
				msg.Metadata = nil // Set to nil or an error indicator if preferred
			}
		}
		messages = append(messages, msg)
	}
	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("message iteration error: %w", err)
	}
	return messages, nil
}

// Update modifies an existing message (e.g., its content or status).
func (r *PostgresMessageRepository) Update(ctx context.Context, msg *chat.Message) error {
	query := `UPDATE messages SET content = $1, status = $2, metadata = $3, updated_at = $4
              WHERE id = $5`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare update message statement: %w", err)
	}
	defer stmt.Close()

	msg.UpdatedAt = time.Now().UTC()
	var metadataJSON []byte
	if msg.Metadata != nil {
		metadataJSON, err = json.Marshal(msg.Metadata)
		if err != nil {
			return fmt.Errorf("failed to marshal message metadata for update: %w", err)
		}
	} else {
		metadataJSON = []byte("{}")
	}

	result, err := stmt.ExecContext(ctx, msg.Content, msg.Status, metadataJSON, msg.UpdatedAt, msg.ID)
	if err != nil {
		return fmt.Errorf("failed to update message: %w", err)
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rowsAffected == 0 {
		return chat.ErrMessageNotFound
	}
	return nil
}

// Delete removes a message from the database.
func (r *PostgresMessageRepository) Delete(ctx context.Context, id string) error {
	query := `DELETE FROM messages WHERE id = $1`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare delete message statement: %w", err)
	}
	defer stmt.Close()

	result, err := stmt.ExecContext(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to delete message: %w", err)
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rowsAffected == 0 {
		return chat.ErrMessageNotFound
	}
	return nil
}
