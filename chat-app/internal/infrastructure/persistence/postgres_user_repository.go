package persistence

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"chat-app/internal/domain/user" // Importing domain user package

	_ "github.com/lib/pq" // PostgreSQL driver
)

// PostgresUserRepository implements the user.UserRepository interface using PostgreSQL.
type PostgresUserRepository struct {
	db *sql.DB
}

// NewPostgresUserRepository creates a new instance of PostgresUserRepository.
func NewPostgresUserRepository(db *sql.DB) *PostgresUserRepository {
	return &PostgresUserRepository{db: db}
}

// Create inserts a new user into the database.
// It assumes the user.ID will be generated by the database (e.g., SERIAL or UUID with default).
// Or, if user.ID is pre-assigned (e.g., UUID generated in service), it uses that.
// For this implementation, we assume ID is generated by DB and returned.
func (r *PostgresUserRepository) Create(ctx context.Context, u *user.User) error {
	query := `INSERT INTO users (username, password_hash, avatar_url, status, description, created_at, updated_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7)
              RETURNING id, created_at, updated_at` // Return ID and timestamps generated by DB

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare create user statement: %w", err)
	}
	defer stmt.Close()

	u.CreatedAt = time.Now().UTC()
	u.UpdatedAt = time.Now().UTC()

	err = stmt.QueryRowContext(ctx, u.Username, u.PasswordHash, u.AvatarURL, u.Status, u.Description, u.CreatedAt, u.UpdatedAt).Scan(&u.ID, &u.CreatedAt, &u.UpdatedAt)
	if err != nil {
		// Could check for specific pq errors, e.g., unique constraint violation for username
		return fmt.Errorf("failed to create user: %w", err)
	}
	return nil
}

// FindByID retrieves a user by their ID.
func (r *PostgresUserRepository) FindByID(ctx context.Context, id string) (*user.User, error) {
	query := `SELECT id, username, password_hash, avatar_url, status, description, created_at, updated_at
              FROM users WHERE id = $1`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare find user by id statement: %w", err)
	}
	defer stmt.Close()

	u := &user.User{}
	err = stmt.QueryRowContext(ctx, id).Scan(
		&u.ID, &u.Username, &u.PasswordHash, &u.AvatarURL,
		&u.Status, &u.Description, &u.CreatedAt, &u.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, user.ErrUserNotFound // Domain-specific error
		}
		return nil, fmt.Errorf("failed to find user by id: %w", err)
	}
	return u, nil
}

// FindByUsername retrieves a user by their username.
func (r *PostgresUserRepository) FindByUsername(ctx context.Context, username string) (*user.User, error) {
	query := `SELECT id, username, password_hash, avatar_url, status, description, created_at, updated_at
              FROM users WHERE username = $1`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare find user by username statement: %w", err)
	}
	defer stmt.Close()

	u := &user.User{}
	err = stmt.QueryRowContext(ctx, username).Scan(
		&u.ID, &u.Username, &u.PasswordHash, &u.AvatarURL,
		&u.Status, &u.Description, &u.CreatedAt, &u.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, user.ErrUserNotFound // Domain-specific error
		}
		return nil, fmt.Errorf("failed to find user by username: %w", err)
	}
	return u, nil
}

// Update modifies an existing user's details in the database.
func (r *PostgresUserRepository) Update(ctx context.Context, u *user.User) error {
	query := `UPDATE users SET username = $1, password_hash = $2, avatar_url = $3, status = $4, description = $5, updated_at = $6
              WHERE id = $7`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare update user statement: %w", err)
	}
	defer stmt.Close()

	u.UpdatedAt = time.Now().UTC()

	result, err := stmt.ExecContext(ctx, u.Username, u.PasswordHash, u.AvatarURL, u.Status, u.Description, u.UpdatedAt, u.ID)
	if err != nil {
		// Could check for specific pq errors, e.g., unique constraint violation for username
		return fmt.Errorf("failed to update user: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rowsAffected == 0 {
		return user.ErrUserNotFound // Or a more generic "update failed" error
	}
	return nil
}

// Delete removes a user from the database by their ID.
func (r *PostgresUserRepository) Delete(ctx context.Context, id string) error {
	query := `DELETE FROM users WHERE id = $1`

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare delete user statement: %w", err)
	}
	defer stmt.Close()

	result, err := stmt.ExecContext(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to delete user: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rowsAffected == 0 {
		return user.ErrUserNotFound
	}
	return nil
}
