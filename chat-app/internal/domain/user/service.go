package user

import (
	"context"
	"errors"
	"fmt"
	"time"

	"golang.org/x/crypto/bcrypt" // For password hashing
	// It's good practice to have a UUID library.
	// For example, "github.com/google/uuid"
	// If not available, ID generation might be handled by the DB
	// or a simpler mechanism for this example.
	// For now, let's assume ID is handled by repository or a utility.
)

var (
	ErrUserNotFound      = errors.New("user not found")
	ErrUsernameTaken     = errors.New("username is already taken")
	ErrInvalidCredentials = errors.New("invalid credentials")
	ErrHashingPassword   = errors.New("failed to hash password")
	ErrPasswordTooShort  = errors.New("password is too short (minimum 8 characters)")
)

// UserService provides business logic operations related to users.
type UserService struct {
	userRepo UserRepository
	// idGenerator func() string // Consider injecting an ID generator
}

// NewUserService creates a new instance of UserService.
func NewUserService(userRepo UserRepository) *UserService {
	return &UserService{
		userRepo: userRepo,
	}
}

// HashPassword generates a bcrypt hash of the password.
func HashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", fmt.Errorf("%w: %w", ErrHashingPassword, err)
	}
	return string(hashedPassword), nil
}

// CheckPasswordHash compares a plaintext password with a bcrypt hash.
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

// RegisterUser creates a new user.
// For now, ID generation is assumed to be handled by the repository or database.
// If not, a UUID should be generated here.
func (s *UserService) RegisterUser(ctx context.Context, username string, password string) (*User, error) {
	if len(password) < 8 {
		return nil, ErrPasswordTooShort
	}

	existingUser, err := s.userRepo.FindByUsername(ctx, username)
	if err != nil && !errors.Is(err, ErrUserNotFound) { // ErrUserNotFound is an error from our repo, not a generic one
		// If FindByUsername returns an error other than "not found", it's an issue
		// For this example, let's assume ErrUserNotFound is a specific error type defined by the repo.
		// If it's a generic sql.ErrNoRows, it would be handled differently.
		// For simplicity, let's assume our repo contract guarantees ErrUserNotFound.
		// If not, we'd check for specific DB driver errors or a generic not found error.
	}
	if existingUser != nil {
		return nil, ErrUsernameTaken
	}

	hashedPassword, err := HashPassword(password)
	if err != nil {
		return nil, err
	}

	// Assuming ID is generated by the database upon creation or repo handles it.
	// If client needs to generate ID:
	// newID, _ := uuid.NewRandom()
	// user.ID = newID.String()
	user := &User{
		// ID: will be set by DB or repo
		Username:     username,
		PasswordHash: hashedPassword,
		Status:       "offline", // Default status
		CreatedAt:    time.Now().UTC(),
		UpdatedAt:    time.Now().UTC(),
	}

	if err := s.userRepo.Create(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}
	// The user object might be updated with ID and other DB-generated fields by Create method.
	return user, nil
}

// GetUserByID retrieves a user by their ID.
func (s *UserService) GetUserByID(ctx context.Context, id string) (*User, error) {
	user, err := s.userRepo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, ErrUserNotFound) { // Assuming repo returns this specific error
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("failed to get user by ID: %w", err)
	}
	return user, nil
}

// GetUserByUsername retrieves a user by their username.
func (s *UserService) GetUserByUsername(ctx context.Context, username string) (*User, error) {
	user, err := s.userRepo.FindByUsername(ctx, username)
	if err != nil {
		if errors.Is(err, ErrUserNotFound) { // Assuming repo returns this specific error
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("failed to get user by username: %w", err)
	}
	return user, nil
}

// UpdateUserProfile updates a user's profile information.
// Only allows changing username, avatarURL, and description.
func (s *UserService) UpdateUserProfile(ctx context.Context, userID string, newUsername, newAvatarURL, newDescription string) (*User, error) {
	user, err := s.userRepo.FindByID(ctx, userID)
	if err != nil {
		return nil, ErrUserNotFound
	}

	if newUsername != "" && newUsername != user.Username {
		// Check if new username is taken
		existing, err := s.userRepo.FindByUsername(ctx, newUsername)
		if err != nil && !errors.Is(err, ErrUserNotFound) {
			return nil, fmt.Errorf("failed to check username availability: %w", err)
		}
		if existing != nil && existing.ID != userID {
			return nil, ErrUsernameTaken
		}
		user.Username = newUsername
	}

	if newAvatarURL != "" {
		user.AvatarURL = newAvatarURL
	}
	if newDescription != "" {
		user.Description = newDescription
	}
	user.UpdatedAt = time.Now().UTC()

	if err := s.userRepo.Update(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to update user profile: %w", err)
	}
	return user, nil
}

// UpdateUserStatus updates a user's online status.
func (s *UserService) UpdateUserStatus(ctx context.Context, userID string, status string) error {
	user, err := s.userRepo.FindByID(ctx, userID)
	if err != nil {
		return ErrUserNotFound
	}

	// TODO: Add validation for allowed status values if necessary
	user.Status = status
	user.UpdatedAt = time.Now().UTC()

	if err := s.userRepo.Update(ctx, user); err != nil {
		return fmt.Errorf("failed to update user status: %w", err)
	}
	return nil
}

// AuthenticateUser checks username and password and returns user if valid.
func (s *UserService) AuthenticateUser(ctx context.Context, username string, password string) (*User, error) {
	user, err := s.userRepo.FindByUsername(ctx, username)
	if err != nil {
		if errors.Is(err, ErrUserNotFound) {
			return nil, ErrInvalidCredentials
		}
		return nil, fmt.Errorf("authentication failed: %w", err)
	}

	if !CheckPasswordHash(password, user.PasswordHash) {
		return nil, ErrInvalidCredentials
	}
	return user, nil
}
